<!DOCTYPE html>
<html lang="en">

    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <title>Voxel Web Renderer Ft. Bar Table - Maxwell Forbes</title>
        
        <meta content="Voxel Web Renderer Ft. Bar Table - Maxwell Forbes" property="title"/>
        <meta content="Voxel Web Renderer Ft. Bar Table - Maxwell Forbes" property="og:title"/>
        <meta name="twitter:title" content="Voxel Web Renderer Ft. Bar Table - Maxwell Forbes"/>

        <link rel="shortcut icon" type="image/svg+xml" href="/assets/img/favicon.svg">
<link rel="shortcut icon" type="image/png" href="/assets/img/favicon.png">

<link href='/assets/css/tachyons.min.css' rel='stylesheet' type='text/css'/>
<link href='/assets/css/style.css' rel='stylesheet' type='text/css'/>
<link href='/assets/css/syntax/prism.default.css' rel='stylesheet' type='text/css'/>
<link href='/assets/css/syntax/prism.okaidia.css' rel='stylesheet' type='text/css'/>



    
    <meta content='https://maxwellforbes.com/sketches/voxel-web-renderer-bar-table/' property='og:url'/>
    
        <meta content='https://maxwellforbes.com/assets/sketches/voxel-web-renderer-bar-table/bar-live-vaporwave-preview.png' property='og:image'/>
        <meta name='twitter:image' content='https://maxwellforbes.com/assets/sketches/voxel-web-renderer-bar-table/bar-live-vaporwave-preview.png'/>
        <meta name='twitter:card' content='summary_large_image'/>
    
    <meta name='twitter:site' content='@maxforbes'/>
    
        <meta content="Hello, this is a sketch of mine, please enjoy" property='og:description'/>
        <meta name='twitter:description' content="Hello, this is a sketch of mine, please enjoy"/>
    
    <meta content="article" property="og:type"/>




    </head>

    <body class="lh-copy pa0 f5 f4-ns sans-serif">
        <script>
            /**
 * Logic:
 * (1) page load
 *   - if manual pref storage is set (light, dark, vaporwave), respect that
 *   - else, if matchMedia() set to dark, do that
 *   - else, light mode
 *
 * (2) setting pref
 *   - if new pref is same as matchMedia(), then clear storage.
 *   - if new pref differs from matchMedia(), set in storage.
 *   - Always set new pref. (Just call (1))
 */

const allowedSchemes = ['light', 'dark', 'vaporwave'];
let curScheme = null;

// theme (str) can be 'dark' or 'light'
function systemWants(theme) {
    return window.matchMedia != null && window.matchMedia('(prefers-color-scheme: ' + theme + ')').matches;
}

function setColorScheme() {
    // default is light
    let desired = "light";

    // if manual pref storage is set (light, dark, vaporwave), respect that
    let userPref = window.localStorage.getItem('color-scheme');
    if (userPref != null && allowedSchemes.indexOf(userPref) != -1) {
        desired = userPref;
    } else if (systemWants("dark")) {
        // or, if matchMedia() set to dark, do that
        desired = "dark";
    }

    curScheme = desired;
    document.documentElement.setAttribute('data-theme', curScheme);

    // NOTE: The display indicator is updated in CSS
}

// click to move along states
function manualColorSchemeClick() {
    // figure out next color in sequence
    let curIndex = allowedSchemes.indexOf(curScheme);
    if (curIndex == -1) {
        console.error("Bad current color scheme:", curScheme);
        return;
    }
    // trigger logic that says user has picked that one
    let newScheme = allowedSchemes[(curIndex + 1) % allowedSchemes.length];

    let systemLight = systemWants("light");
    let systemDark = systemWants("dark");

    // if new pref is same as matchMedia(), then clear storage.
    if ((newScheme == "light" && systemLight) || (newScheme == "dark" && systemDark)) {
        window.localStorage.removeItem('color-scheme');
    } else {
        // if new pref differs from matchMedia(), set in storage.
        window.localStorage.setItem("color-scheme", newScheme);
    }

    // always set new scheme
    setColorScheme();
}

// Listener for when system color scheme changed. Call logic again.
window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
    setColorScheme();
});

// Set scheme on page load.
setColorScheme();

        </script>

        

    <!-- Back banner -->
    
    
    <div class="bg-white fixed z-2 o-70">
        <p class="f6 ph3">
            <a href="/studio#sketches" class="dim">
                &#8592; sketches
            </a>
        </p>
    </div>

    <div class="vh-100 dt w-100">
        <div class="dtc v-mid tc" id="container">
            <script type="module">
    // latest version @ https://unpkg.com/three
    import * as THREE from 'https://unpkg.com/three@0.127.0/build/three.module.js';
    import { VOXLoader, VOXMesh } from 'https://unpkg.com/three@0.127.0/examples/jsm/loaders/VOXLoader.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.127.0/examples/jsm/controls/OrbitControls.js';

    const scene = new THREE.Scene();
    // scene.background = new THREE.Color( 0xadd5f7 );
    scene.background = new THREE.Color( 0xE33682 );
    const camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 1000 );
    camera.position.set(-3.02, -0.173, 2.86);

    const renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setPixelRatio( window.devicePixelRatio );
    renderer.setSize( window.innerWidth, window.innerHeight );
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.getElementById("container").appendChild( renderer.domElement );

    // const geometry = new THREE.BoxGeometry();
    // const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
    // const cube = new THREE.Mesh( geometry, material );
    // scene.add( cube );

    const group = new THREE.Group();
    const loader = new VOXLoader();
    loader.load('/assets/sketches/voxel-web-renderer-bar-table/08_Bar Table.vox', function ( chunks ) {
        for ( let i = 0; i < chunks.length; i ++ ) {
            const chunk = chunks[ i ];

            // displayPalette( chunk.palette );

            const mesh = new VOXMesh( chunk );
            // mesh.scale.setScalar( 0.0015 );
            mesh.scale.setScalar(0.1);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            group.add( mesh );

        }

    } );
    scene.add(group);

    // controls
    let controls = new OrbitControls( camera, renderer.domElement );
    controls.minDistance = .1;
    controls.maxDistance = 25;
    controls.target.set(0, -0.5, 0);
    // controls.autoRotate = true;

    // lights

    const hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.3 );
    scene.add( hemiLight );

    // const dirLight = new THREE.DirectionalLight( 0xF5F0C0, 0.9 );
    const dirLight = new THREE.DirectionalLight( 0xFFFFFF, 0.9 );
    // dirLight.position.set(-1, 1, -1);
    dirLight.position.set(-3.02, -0.173, 2.86);
    dirLight.castShadow = true;
    scene.add( dirLight );

    // const pointLight = new THREE.PointLight(0xff5555, 1);
    const pointLight = new THREE.PointLight(0xff00ff, 1);
    pointLight.position.set(-3, 1, -3);
    pointLight.castShadow = true;
    scene.add(pointLight);

    const sphereSize = 0.5;
    const pointLightHelper = new THREE.PointLightHelper( pointLight, sphereSize );
    // scene.add( pointLightHelper );

    // const pointLight2 = new THREE.PointLight(0xF5F487, 1);
    // pointLight2.position.set(1, 0.5, -1);
    // pointLight2.castShadow = true;
    // scene.add(pointLight2);

    // const pointLightHelper2 = new THREE.PointLightHelper( pointLight2, sphereSize );
    // scene.add( pointLightHelper2 );

    // handle resizing
    function onWindowResize(){
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );
        // console.log(camera.position);
    }
    window.addEventListener( 'resize', onWindowResize, false );

    const animate = function () {
        requestAnimationFrame( animate );

        controls.update()

        // scene.rotation.x += 0.01;
        // scene.rotation.y += 0.003;
        group.rotation.y -= 0.003;

        // postprocessing.composer.render( 0.1 );
        renderer.render( scene, camera );
    };

    animate();

</script>

        </div>
    </div>


    </body>

</html>
